options {
  /* default values here:
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  */
  
  // we define our own token manager
  USER_TOKEN_MANAGER = true;
  STATIC = false;
}

PARSER_BEGIN(WyvernParser)

package wyvern.tools.parsing.coreparser;

import wyvern.tools.typedAST.abs.*;
import wyvern.tools.typedAST.interfaces.*;
import wyvern.tools.typedAST.core.*;
import wyvern.tools.typedAST.core.values.*;
import wyvern.tools.typedAST.core.binding.*;
import wyvern.tools.typedAST.core.expressions.*;
import wyvern.tools.typedAST.core.declarations.*;
import wyvern.tools.errors.*;

import java.net.URI;
import java.util.*;

/** Simple brace matcher. */
public class WyvernParser<AST,Type> {
    private int number = 0;
    
    public FileLocation loc(Token t) {
    	return new FileLocation(getTM().getFilename(), t.beginLine, t.beginColumn);
    }
    
    public WyvernTokenManager getTM() {
    	return (WyvernTokenManager) token_source;
    }
    
    public String freshName() {
    	return "ignoreme" + number++;
    }
    
    private ASTBuilder<AST,Type> build;
    public void setBuilder(ASTBuilder<AST,Type> builder) { build = builder; }
}

PARSER_END(WyvernParser)

SPECIAL_TOKEN : /* Comments and whitespace */
{
  <SINGLE_LINE_COMMENT>
| <MULTI_LINE_COMMENT>
| <WHITESPACE>
}

TOKEN : /* Keywords */
{
  < VAL: "val" >
| < VAR: "var" >
| < FN: "fn" >
| < DEF: "def" >
| < TYPE: "type" >
| < CLASS: "class" >
| < REQUIRE: "require" >
| < METADATA: "metadata" >
| < NEW: "new" >
| < MODULE: "module" >
| < IMPORT: "import" >
//| < : "" >
// more here
}

TOKEN : /* Logical Formatting */
{
  <NEWLINE>
| <INDENT>
| <DEDENT>
| <DSLLINE>
}

TOKEN : /* Identifiers */
{
  <IDENTIFIER>
}

TOKEN : /* Symbols */
{
  <LPAREN>
| <RPAREN>
| <TILDE>
| <PLUS>
| <DASH>
| <MULT>
| <DIVIDE>
| <EQUALS>
| <EQUALSEQUALS>
| <COMMA>
| <ARROW>
| <TARROW>
| <DOT>
| <COLON>
| <POUND>
| <QUESTION>
| <BAR>
| <AND>
| <GT>
| <LT>
| <LBRACK>
| <RBRACK>
| <LBRACE>
| <RBRACE>
//| <>
}

TOKEN : /* Literals */
{
  < STRING_LITERAL >
| < DECIMAL_LITERAL >
| < RATIONAL_LITERAL >
}

/** Root production. */
AST CompilationUnit() :
{ AST exp; Token id; }
{
  exp = ModuleBody(false)  { return exp; }
|
  <MODULE> id = <IDENTIFIER> OptType() <NEWLINE> exp = ModuleBody(true) {
	return build.moduleDecl(id.image, exp, loc(id));
  }
}

Type OptType() :
{ Type t; }
{
  <COLON> t = Type()  { return t; }
|
  /* nothing */ { return null; }
}

AST ModuleBody(boolean inModule) :
{ AST ast; AST decl; }
{
  ast = DeclSequence(inModule)  { return ast; }
|
  decl = RequireDecl() ast = ModuleBody(inModule) { return build.sequence(decl,ast,inModule); }
|
  decl = ImportDecl() ast = ModuleBody(inModule) { return build.sequence(decl,ast,inModule); }
}

AST RequireDecl() :
{ URI uri; Token t; }
{
  t=<REQUIRE> uri = Uri() <NEWLINE>  { return build.importDecl(uri, loc(t)); }
}

AST ImportDecl() :
{ URI uri; Token t; }
{
  t=<IMPORT> uri = Uri() <NEWLINE> { return build.importDecl(uri, loc(t)); }
}

URI Uri() :
{ Token t; String scheme = null; String s1; String s2; URI uri; }
{
	[ LOOKAHEAD(2) t = <IDENTIFIER> <COLON> { scheme = t.image; } ]
	s1 = Segment() ( <DIVIDE> s2 = Segment() { s1 = s1 + '/' + s2; } )* {
		if (scheme == null)
			scheme = "wyv";
   		try {
			return new URI(scheme, s1, null);
   		} catch (Exception e) { throw new RuntimeException(e); }
	}
}

String Segment() :
{ String s; Token t1; }
{
	t1 = <IDENTIFIER> { s = t1.image; }	
	( <DOT> t1 = <IDENTIFIER> { s = s + '.' + t1.image; } )* { return s; }
}

AST DeclSequence(boolean inModule) :
{ AST decl1; AST decl2; }
{
  decl1 = Declaration(inModule)
  ( decl2 = Declaration(inModule) { decl1 = build.sequence(decl1, decl2, inModule); } )*
    { return decl1; }
}

AST Declaration(boolean inModule) :
{ AST exp; Token t; }
{
  exp = DefDeclaration()  { return exp; }
|
  exp = ValDeclaration()  { return exp; }
|
  exp = VarDeclaration()  { return exp; }
|
  exp = Expression() t=<NEWLINE> {
    if (!inModule)
    	return exp;
  	else
  		return build.valDecl(freshName(), null, exp, loc(t));
  }
}

AST DefDeclaration() :
{ Type resultType; Token name; AST body; List args; }
{
  <DEF> name=<IDENTIFIER> args = Formals() <COLON> resultType = Type() body=DefBody() {
	return build.defDecl(name.image, resultType, args, body, false, loc(name));
  }
}

AST ValDeclaration() :
{ Type type = null; Token name; AST body; List args; }
{
  <VAL> name=<IDENTIFIER> [ <COLON> type = Type() ] <EQUALS> body = Expression() <NEWLINE> {
	return build.valDecl(name.image, type, body, loc(name));
  }
}

AST VarDeclaration() :
{ Type type; Token name; AST body; List args; }
{
  <VAR> name=<IDENTIFIER> <COLON> type = Type() <EQUALS> body = Expression() <NEWLINE> {
	return build.valDecl(name.image, type, body, loc(name));
  }
}

List Formals() :
{ List args = new LinkedList(); }
{
  <LPAREN> [ FormalsList(args) ] <RPAREN> {
			return args;
		}
}

void FormalsList(List args) :
{ Object formal; }
{
  formal = Formal() {
      args.add(formal);
  }
  ( <COMMA> formal = Formal() {
      args.add(formal);
	}
  )*
}

Object Formal() :
{ Token id; Type type; }
{
  id = <IDENTIFIER> <COLON> type = Type() {
      return build.formalArg(id.image, type);
  }
}

AST DefBody() :
{ AST exp; }
{
  <NEWLINE> <INDENT> exp = Expression() <NEWLINE> <DEDENT> { return exp; }
}

AST Expression() :
{ AST exp; Object formal; }
{
  exp = PrimaryExpression()  { return exp; }
|
  <FN> formal = Formal() <ARROW> exp = Expression() { return build.fn(Arrays.asList(formal), exp); }
}

Type Type() :
{ Token id; }
{
  id = <IDENTIFIER> { return build.nominalType(id.image); }
}

AST PrimaryExpression() :
{ AST exp; }
{
  exp = PrimaryPrefix() ( exp = PrimarySuffix(exp) )*  { return exp; }
}

AST PrimaryPrefix() :
{ AST exp; Token t; }
{
  exp = Literal() { return exp; }
|
  t = <IDENTIFIER> { return build.var(t.image, loc(t)); }
|
  <LPAREN> exp = Expression() <RPAREN> { return exp; }
}

AST Literal() :
{ Token lit; }
{
  lit = <STRING_LITERAL>  { return build.stringLit(lit.image); }
|
  lit = <DECIMAL_LITERAL> { return build.integerLit(Integer.parseInt(lit.image)); }
|
  <RATIONAL_LITERAL>
}

AST PrimarySuffix(AST lhs) :
{ AST rhs; Token t; }
{
  <DOT> t = <IDENTIFIER> { return build.invocation(lhs, t.image, null, loc(t)); }
|
  rhs = Arguments() { return build.application(lhs, rhs, null); }
}

AST Arguments() :
{ AST exp = null; Token t; }
{
  t = <LPAREN> [ exp = ArgumentList() ] <RPAREN> {
  			if (exp == null)
  				return build.unitValue(loc(t));
  			else
				return exp;
		}
}

AST ArgumentList() :
{ AST exp; AST exp2; LinkedList<AST> expList = null; Token t; }
{
  exp = Expression()
  ( t=<COMMA> exp2 = Expression() {
  		if (expList == null) {
  			expList = new LinkedList<AST>();
  			expList.add(exp);
  		}
  		expList.addLast(exp2);
	}
  )* {
  		if (expList != null) {
  			return build.tuple(expList); 
  		}
  		return exp;
  	}
}
