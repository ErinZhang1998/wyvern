options {
  /* default values here:
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  */
  
  // we define our own token manager
  USER_TOKEN_MANAGER = true;
  STATIC = false;
}

PARSER_BEGIN(WyvernParser)

package wyvern.tools.parsing.coreparser;

import wyvern.tools.typedAST.interfaces.*;
import wyvern.tools.typedAST.core.values.*;
import wyvern.tools.typedAST.core.binding.*;
import wyvern.tools.typedAST.core.expressions.*;
import wyvern.tools.types.*;
import wyvern.tools.errors.*;

import java.util.*;

/** Simple brace matcher. */
public class WyvernParser {
    public FileLocation loc(Token t) {
    	return new FileLocation(getTM().getFilename(), t.beginLine, t.beginColumn);
    }
    
    public WyvernTokenManager getTM() {
    	return (WyvernTokenManager) token_source;
    }
}

PARSER_END(WyvernParser)

SPECIAL_TOKEN : /* Comments and whitespace */
{
  <SINGLE_LINE_COMMENT>
| <MULTI_LINE_COMMENT>
| <WHITESPACE>
}

TOKEN : /* Keywords */
{
  < VAL: "val" >
| < VAR: "var" >
| < FN: "fn" >
// more here
}

TOKEN : /* Logical Formatting */
{
  <NEWLINE>
| <INDENT>
| <DEDENT>
| <DSLLINE>
}

TOKEN : /* Identifiers */
{
  <IDENTIFIER>
}

TOKEN : /* Symbols */
{
  <LPAREN>
| <RPAREN>
| <TILDE>
| <PLUS>
| <DASH>
| <MULT>
| <DIVIDE>
| <EQUALS>
| <EQUALSEQUALS>
| <COMMA>
| <ARROW>
| <TARROW>
| <DOT>
| <COLON>
| <POUND>
| <QUESTION>
| <BAR>
| <AND>
| <GT>
| <LT>
| <LBRACK>
| <RBRACK>
| <LBRACE>
| <RBRACE>
//| <>
}

TOKEN : /* Literals */
{
  < STRING_LITERAL >
| < DECIMAL_LITERAL >
| < RATIONAL_LITERAL >
}

/** Root production. */
TypedAST Expression() :
{ TypedAST exp; Token id; Type type; }
{
  exp = PrimaryExpression()  { return exp; }
|
  <FN> id = <IDENTIFIER> <COLON> type = Type() <ARROW> exp = Expression() { return new Fn(Arrays.asList(new NameBindingImpl(id.image, type)), exp); }
}

Type Type() :
{ Token id; }
{
  id = <IDENTIFIER> { return new UnresolvedType(id.image); }
}

TypedAST PrimaryExpression() :
{ TypedAST exp; }
{
  exp = PrimaryPrefix() ( exp = PrimarySuffix(exp) )*  { return exp; }
}

TypedAST PrimaryPrefix() :
{ TypedAST exp; Token t; }
{
  exp = Literal() { return exp; }
|
  t = <IDENTIFIER> { return new Variable(new NameBindingImpl((String)t.image, null), loc(t)); }
|
  <LPAREN> exp = Expression() <RPAREN> { return exp; }
}

TypedAST Literal() :
{ Token lit; }
{
  lit = <STRING_LITERAL>  { return new StringConstant(lit.image); }
|
  lit = <DECIMAL_LITERAL> { return new IntegerConstant(Integer.parseInt(lit.image)); }
|
  <RATIONAL_LITERAL>
}

TypedAST PrimarySuffix(TypedAST lhs) :
{ TypedAST rhs; Token t; }
{
  <DOT> t = <IDENTIFIER> { return new Invocation(lhs, t.image, null, loc(t)); }
|
  rhs = Arguments() { return new Application(lhs, rhs, null); }
}

TypedAST Arguments() :
{ TypedAST exp = null; }
{
  <LPAREN> [ exp = ArgumentList() ] <RPAREN> {
  			if (exp == null)
  				return UnitVal.getInstance(null);
  			else
				return exp;
		}
}

TypedAST ArgumentList() :
{ TypedAST exp; TypedAST exp2; LinkedList<TypedAST> expList = null; Token t; }
{
  exp = Expression()
  ( t=<COMMA> exp2 = Expression() {
  		if (expList == null) {
  			expList = new LinkedList<TypedAST>();
  			expList.add(exp);
  		}
  		expList.addLast(exp2);
	}
  )* {
  		if (expList != null) {
  			return new TupleObject(expList); 
  		}
  		return exp;
  	}
}
