/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ArchParser.jj */
/*@egen*/options
{
                           
	             
	               
    STATIC = false;
    USER_TOKEN_MANAGER = true;
}

PARSER_BEGIN(ArchParser)

package wyvern.tools.parsing.coreparser.arch;

import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import wyvern.tools.arch.lexing.ArchLexer;
import java.io.FileNotFoundException;
import java.io.IOException;
import edu.umn.cs.melt.copper.runtime.logging.CopperParserException;
import wyvern.tools.parsing.coreparser.WyvernTokenManager;
import wyvern.tools.parsing.coreparser.TokenManager;
import wyvern.tools.parsing.coreparser.Token;
import wyvern.tools.parsing.coreparser.ParseException;

public class ArchParser/*@bgen(jjtree)*/implements ArchParserTreeConstants/*@egen*/   {/*@bgen(jjtree)*/
  protected JJTArchParserState jjtree = new JJTArchParserState();

/*@egen*/ 

    public static String kindToName(int kind) {
      switch (kind) {
      case MULTI_LINE_COMMENT: return "MULTI_LINE_COMMENT";
      case COMMA: return "COMMA";
      case ATTACHMENTS: return "ATTACHMENTS";
      case IS: return "IS";
      case BINDINGS: return "BINDINGS";
      case ENTRYPOINTS: return "ENTRYPOINTS";
      case CONNECT: return "CONNECT";
      case DOT: return "DOT";
      case AND: return "AND";
      case WITH: return "WITH";
      case CONNECTORS: return "CONNECTORS";
      case COMPONENTS: return "COMPONENTS";
      case ARCHITECTURE: return "ARCHITECTURE";
      case VAL: return "VAL";
      case CONNECTOR: return "CONNECTOR";
      case COMPONENT: return "COMPONENT";
      case PORT: return "PORT";
      case COLON: return "COLON";
      case IDENTIFIER: return "IDENTIFIER";
      case WHITESPACE: return "WHITESPACE";
      case DEDENT: return "DEDENT";
      case INDENT: return "INDENT";
      case NEWLINE: return "NEWLINE";
      case PROVIDES: return "PROVIDES";
      case REQUIRES: return "REQUIRES";
      default: return "UNKNOWN(" + kind + ")";
      }
    }
    
    public static void main(String []args) throws CopperParserException, IOException, FileNotFoundException {
        String root = System.getProperty("user.dir");
        File example1, example2, example3;
        if (root.substring(root.length() - 5).equals("tools"))  {
          example1 = new File(root + "/../examples/architecture/example1.wyc");
          example2 = new File(root + "/../examples/architecture/example2.wyc");
          example3 = new File(root + "/../examples/architecture/example3.wyc");
        } else  {
          example1 = new File(root + "/../../examples/architecture/example1.wyc");
          example2 = new File(root + "/../../examples/architecture/example2.wyc");
          example3 = new File(root + "/../../examples/architecture/example3.wyc");
        }
        BufferedReader source = new BufferedReader(new FileReader(
                                                                  //    example1
                                                                      example2
                                                                  //    example3
                                                                    ));
        ArchParser wp = new ArchParser(
                (TokenManager) new WyvernTokenManager<ArchLexer, ArchParserConstants>(source, "test", ArchLexer.class,
                        ArchParserConstants.class));

        /*Full list of tokens as collected by the token manager
        List<Token> tokens = new ArchLexer().parse(source, "test");
        for (Token t: tokens) {
          if (!kindToName(t.kind).equals("WHITESPACE")){
            System.out.println(kindToName(t.kind));
          }
        }*/
        
        //Parsing attempt
        try {
          wp.ArchDesc();
        } catch (ParseException e)  {
          e.printStackTrace();
        }

        /*What's left after parsing attempt*/
        Token t = wp.getNextToken();
        while (!kindToName(t.kind).equals("UNKNOWN(0)")){
            System.out.println(kindToName(t.kind));
            t = wp.getNextToken();
        }
        
        System.out.println("~PARSING DONE~");

    }
}

PARSER_END(ArchParser)

SPECIAL_TOKEN : /* Comments and whitespace */
{
  <SINGLE_LINE_COMMENT>
| <MULTI_LINE_COMMENT>
| <WHITESPACE>
}

TOKEN : /* Keywords */
{
  <COMPONENT: "component">
| <EXTERNAL: "external">
| <PORT: "port">
| <PROVIDES: "provides">
| <REQUIRES: "requires">
| <CONNECTOR: "connector">
| <VAL: "val">
| <ARCHITECTURE: "architecture">
| <COMPONENTS: "components">
| <CONNECTORS: "connectors">
| <ATTACHMENTS: "attachments">
| <CONNECT: "connect">
| <AND: "and">
| <WITH: "with">
| <ENTRYPOINTS: "entryPoints">
| <BINDINGS: "bindings">
| <IS: "is">
}

TOKEN : /* Logical Formatting */
{
  <DEDENT>
| <INDENT>
| <NEWLINE>
}

TOKEN : /* Identifiers */
{
  <IDENTIFIER>
}

TOKEN : /* Symbols */
{
  <COLON: ":">
| <DOT: ".">
| <COMMA: ",">
}

/** Root production. */
void ArchDesc()       :
{ Node exp; }
{
    exp = ArchTypeDeclSeq()
}

Node ArchTypeDeclSeq() : 
{/*@bgen(jjtree) ArchTypeDeclSeq */
  ASTArchTypeDeclSeq jjtn000 = new ASTArchTypeDeclSeq(JJTARCHTYPEDECLSEQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Node ast1; Node ast2; }
{/*@bgen(jjtree) ArchTypeDeclSeq */
    try {
/*@egen*/
    ast1 = ArchTypeDecls() 
    ( ast2 = ArchTypeDecls() {  } )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }
|
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    //{ return ast1; }
}

Node ArchTypeDecls()       : 
{ Node exp; }
{
    exp = ComponentTypeDecl()       { return null; }//{ return exp; }
|
    exp = ConnectorTypeDecl()       { return null; }//{ return exp; }
|
    exp = ArchitectureTypeDecl()    { return null; }//{ return exp; }
}

Node ComponentTypeDecl() : 
{/*@bgen(jjtree) ComponentTypeDecl */
  ASTComponentTypeDecl jjtn000 = new ASTComponentTypeDecl(JJTCOMPONENTTYPEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token name; boolean isExternal; Node exp1; Node exp2; }
{/*@bgen(jjtree) ComponentTypeDecl */
    try {
/*@egen*/
    [ <EXTERNAL> { isExternal=true; } ] <COMPONENT> name=<IDENTIFIER>
    <NEWLINE> <INDENT> exp1 = ComponentTypeDeclBody()
            ( exp2 = ComponentTypeDeclBody() {  } )*
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*///{ return build.componentTypeDecl(); }
}


Node ComponentTypeDeclBody()       : 
{ Node ast1; Node ast2; }
{
    ast1 = MemberDecls()            { return null; }//{ return ast1; }
|
    ast1 = ArchTypeDecls()          { return null; }//{ return ast1; }
|
    ast1 = BindingDecls()           { return null; }//{ return ast1; }

}

Node ConnectorTypeDecl() : 
{/*@bgen(jjtree) ConnectorTypeDecl */
  ASTConnectorTypeDecl jjtn000 = new ASTConnectorTypeDecl(JJTCONNECTORTYPEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token name; Node exp1; Node exp2; }
{/*@bgen(jjtree) ConnectorTypeDecl */
    try {
/*@egen*/
    <CONNECTOR> name=<IDENTIFIER>
    <NEWLINE> <INDENT> exp1 = ValDecl()
    (exp2 = ValDecl())*
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node ArchitectureTypeDecl() : 
{/*@bgen(jjtree) ArchitectureTypeDecl */
  ASTArchitectureTypeDecl jjtn000 = new ASTArchitectureTypeDecl(JJTARCHITECTURETYPEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token name; Node body; }
{/*@bgen(jjtree) ArchitectureTypeDecl */
    try {
/*@egen*/
    <ARCHITECTURE> name=<IDENTIFIER>
    <NEWLINE> <INDENT> body = ArchElemDeclSeq()
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*///{ return build.architectureTypeDecl(); }
}

Node ArchElemDeclSeq() : 
{/*@bgen(jjtree) ArchElemDeclSeq */
  ASTArchElemDeclSeq jjtn000 = new ASTArchElemDeclSeq(JJTARCHELEMDECLSEQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Node exp1; Node exp2; }
{/*@bgen(jjtree) ArchElemDeclSeq */
    try {
/*@egen*/
    exp1 = ArchElemDecls() 
    (exp2 = ArchElemDecls() { } )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node ArchElemDecls()       : 
{ Node exp; }
{
    exp = ComponentDecls()      { return null; }//{ return exp; }
|
    exp = ConnectorDecls()      { return null; }//{ return exp; }
|
    exp = AttachmentDecls()     { return null; }//{ return exp; }
|
    exp = EntryPointDecls()     { return null; }//{ return exp; }
}

Node ComponentDecls() :
{/*@bgen(jjtree) ComponentDecls */
  ASTComponentDecls jjtn000 = new ASTComponentDecls(JJTCOMPONENTDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token type; Token name; boolean isExternal = false; }
{/*@bgen(jjtree) ComponentDecls */
    try {
/*@egen*/
    <COMPONENTS>
    <NEWLINE> <INDENT> 
            type=<IDENTIFIER> name=<IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <NEWLINE>
            (type=<IDENTIFIER> name=<IDENTIFIER> ( <COMMA> <IDENTIFIER> )*  <NEWLINE>)*
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node ConnectorDecls() : 
{/*@bgen(jjtree) ConnectorDecls */
  ASTConnectorDecls jjtn000 = new ASTConnectorDecls(JJTCONNECTORDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token type; Token name; boolean isExternal = false; }
{/*@bgen(jjtree) ConnectorDecls */
    try {
/*@egen*/
    <CONNECTORS> 
    <NEWLINE> <INDENT> 
            type=<IDENTIFIER> name=<IDENTIFIER> ( <COMMA> <IDENTIFIER> )* <NEWLINE>
            (type=<IDENTIFIER> name=<IDENTIFIER> ( <COMMA> <IDENTIFIER> )*  <NEWLINE>)*
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node AttachmentDecls() : 
{/*@bgen(jjtree) AttachmentDecls */
  ASTAttachmentDecls jjtn000 = new ASTAttachmentDecls(JJTATTACHMENTDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ String p1; String p2; Token cntr; }
{/*@bgen(jjtree) AttachmentDecls */
    try {
/*@egen*/
    //allow for multiple cmp.prt in connect statement
    <ATTACHMENTS>
    <NEWLINE> <INDENT> 
    <CONNECT> p1=Segment() <AND> p2=Segment() ( <AND> Segment() )* <WITH> cntr=<IDENTIFIER> <NEWLINE>
              (p1=Segment() <AND> p2=Segment() ( <AND> Segment() )* <WITH> cntr=<IDENTIFIER> <NEWLINE>)*
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node BindingDecls() :
{/*@bgen(jjtree) BindingDecls */
  ASTBindingDecls jjtn000 = new ASTBindingDecls(JJTBINDINGDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String b; }
{/*@bgen(jjtree) BindingDecls */
    try {
/*@egen*/
    <BINDINGS>
    <NEWLINE> <INDENT> t=<IDENTIFIER> <IS> b=Segment() <NEWLINE>
    (t=<IDENTIFIER> <IS> b=Segment() {} <NEWLINE> )*
    <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node EntryPointDecls() : 
{/*@bgen(jjtree) EntryPointDecls */
  ASTEntryPointDecls jjtn000 = new ASTEntryPointDecls(JJTENTRYPOINTDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; Token point; }
{/*@bgen(jjtree) EntryPointDecls */
    try {
/*@egen*/
    <ENTRYPOINTS>
    <NEWLINE> <INDENT> <IDENTIFIER> <COLON> <IDENTIFIER> <NEWLINE>
    (<IDENTIFIER> <COLON> <IDENTIFIER> <NEWLINE>)* 
            <DEDENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Node MemberDecls()       :
{ Node exp1; Node exp2; }
{
    ( exp1 = ValDecl() | exp1 = PortDecl() )
    { return null; }//{ return exp1; }
}

Node PortDecl() :
{/*@bgen(jjtree) PortDecl */
  ASTPortDecl jjtn000 = new ASTPortDecl(JJTPORTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token p; Token req = null; Token prov = null; }
{/*@bgen(jjtree) PortDecl */
    try {
/*@egen*/
    <PORT> p=<IDENTIFIER> <COLON> (<REQUIRES> req=<IDENTIFIER> | 
                        <PROVIDES> prov=<IDENTIFIER>) <NEWLINE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*///{ return build.portDecl(); }
}

Node ValDecl() :
{/*@bgen(jjtree) ValDecl */
  ASTValDecl jjtn000 = new ASTValDecl(JJTVALDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; Token name; }
{/*@bgen(jjtree) ValDecl */
    try {
/*@egen*/
    <VAL> name=<IDENTIFIER> <COLON> t=<IDENTIFIER> <NEWLINE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return null; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*///{ return build.valDecl(); }
}

String Segment()       : 
{ String s; Token t; }
{
    t=<IDENTIFIER> { s = t.image; }
    ( <DOT> t=<IDENTIFIER> { s = s + "." + t.image; } )* 
    { return null; }//{ return s; }
}








