/* Generated By:JJTree: Do not edit this line. ASTConnectorTypeDecl.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package wyvern.tools.parsing.coreparser.arch;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

import wyvern.target.corewyvernIL.VarBinding;
import wyvern.target.corewyvernIL.decl.Declaration;
import wyvern.target.corewyvernIL.decl.TypeDeclaration;
import wyvern.target.corewyvernIL.decltype.DeclType;
import wyvern.target.corewyvernIL.decltype.ValDeclType;
import wyvern.target.corewyvernIL.expression.New;
import wyvern.target.corewyvernIL.expression.SeqExpr;
import wyvern.target.corewyvernIL.modules.Module;
import wyvern.target.corewyvernIL.support.InterpreterState;
import wyvern.target.corewyvernIL.type.NominalType;
import wyvern.target.corewyvernIL.type.StructuralType;
import wyvern.tools.errors.ErrorMessage;
import wyvern.tools.errors.HasLocation;
import wyvern.tools.errors.ToolError;

public class ASTConnectorTypeDecl extends SimpleNode {
  private String typeName;
  private HashMap<String, String> vals = new HashMap<>();

  public ASTConnectorTypeDecl(int id) {
    super(id);
  }

  public ASTConnectorTypeDecl(ArchParser p, int id) {
    super(p, id);
  }

  public String getTypeName() {
    return typeName;
  }

  public void setTypeName(String t) {
    typeName = t;
  }

  public String toString() {
    return super.toString() + " " + typeName;
  }

  public void collectVals() {
    for (Node child : children) {
      if (child instanceof ASTValDecl) {
        String name = ((ASTValDecl) child).getName();
        String type = ((ASTValDecl) child).getType();
        vals.put(name, type);
      }
    }
  }

  public boolean checkModule() {
    String rootLoc = null, wyvernPath = null;
    Module mod = null;

    try {
      rootLoc = System.getenv("WYVERN_ROOT");
      if (rootLoc == null) {
        rootLoc = System.getProperty("user.dir");
      }

      wyvernPath = System.getenv("WYVERN_HOME");
      if (wyvernPath == null) {
        System.err.println(
            "must set WYVERN_HOME environmental variable to wyvern project directory");
        return false;
      }

      wyvernPath += "/stdlib/";
      // sanity check: is the wyvernPath a valid directory?
      if (!Files.isDirectory(Paths.get(wyvernPath))) {
        System.err.println(
            "Error: WYVERN_HOME is not set to a valid Wyvern project directory");
        return false;
      }
    } catch (ToolError e) {
      System.err.println(e.getMessage());
    }

    InterpreterState state = new InterpreterState(
        InterpreterState.PLATFORM_JAVA, new File(rootLoc),
        new File(wyvernPath));

    try {
      int checkCount = 0;
      mod = state.getResolver().resolveType(typeName);
      SeqExpr expr = (SeqExpr) mod.getExpression();

      /* Check that the wyvern type vals match architecture vals */
      List<HasLocation> varbindings = expr.getElements().stream()
          .filter(p -> p instanceof VarBinding).collect(Collectors.toList());
      for (HasLocation v : varbindings) {
        New nExpr = (New) ((VarBinding) v).getExpression();
        List<Declaration> typedeclarations = nExpr.getDecls().stream()
            .filter(p -> p instanceof TypeDeclaration)
            .collect(Collectors.toList());
        for (Declaration d : typedeclarations) {
          StructuralType st = (StructuralType) ((TypeDeclaration) d)
              .getSourceType();
          List<DeclType> valdecltypes = st.getDeclTypes().stream()
              .filter(p -> p instanceof ValDeclType)
              .collect(Collectors.toList());
          for (DeclType dt : valdecltypes) {
            String name = dt.getName();
            String type = ((NominalType) ((ValDeclType) dt).getRawResultType())
                .getTypeMember();
            String ty;
            if ((ty = vals.get(name)) != null) {
              if (!ty.equals(type)) {
                // connector val type mismatch
                ToolError.reportError(ErrorMessage.CONNECTOR_VAL_INCONSISTENCY,
                    location, typeName);
                return false;
              } else {
                checkCount++;
              }
            } else {
              // connector val not found
              ToolError.reportError(ErrorMessage.CONNECTOR_VAL_INCONSISTENCY,
                  location, typeName);
              return false;
            }
          }
          if (checkCount != vals.size()) {
            ToolError.reportError(ErrorMessage.CONNECTOR_VAL_INCONSISTENCY,
                location, typeName);
            return false;
          }
          return true;
        }
      }
    } catch (

    ToolError e)

    {
      e.printStackTrace();
      return false;
    }

    return true;

  }

  /** Accept the visitor. **/
  public Object jjtAccept(ArchParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }
}
/*
 * JavaCC - OriginalChecksum=884a938c5fd0ec5939d4c5c7e8dc6912 (do not edit this
 * line)
 */
