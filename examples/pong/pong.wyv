import python:pygame
import python:helper
import python:time

type Surface
  def fill(color : Color) : Unit

resource type Rect
  var top : Int
  var left : Int
  var bottom : Int
  var right : Int

type Color

type Clock
  def tick(fps : Int) : Unit

type Draw
  def rect(surface : Surface,
           color : Color,
           rect : Rect,
           width : Int) : Rect
  def circle(surface : Surface,
             color : Color,
             center : Dyn,
             radius : Int) : Unit

type EventType = Int
type Key = Int

type Event
  val key : Key

type PygameEvent
  def poll() : Event

type Display
  def set_mode(size : Dyn,
               flags : Int,
               depth : Int) : Surface
  def flip() : Unit

type Helper
  def make2Tuple(a : Dyn, b : Dyn) : Dyn
  def fst(a : Dyn) : Dyn
  def snd(a : Dyn) : Dyn
  def makeRect(left : Int, top : Int, width : Int, height : Int) : Rect
  val white : Color
  val black : Color
  def makeClock() : Clock
  def debug(msg : String) : Unit
  def getType(event : Event) : EventType
val helper : Helper = helper

type Pygame
  def init() : Unit
  def quit() : Unit

  val draw : Draw
  val display : Display
  val event : PygameEvent

  def Rect(x : Int, y : Int, height : Int, width : Int) : Rect
  val QUIT : EventType
  val KEYDOWN : EventType
  val KEYUP : EventType
  val MOUSEBUTTONDOWN : EventType
  val MOUSEBUTTONUP : EventType
  val NOEVENT : EventType

  val K_UP : Key
  val K_DOWN : Key

type Time
  def sleep(t : Int) : Unit
val time : Time = time

val pygame : Pygame = pygame

resource type GameLoop
  val fps : Int
  val done : Boolean
  def oneIteration() : Unit
  def processEvent(e : Event) : Unit
val clock : Clock = helper.makeClock()
def processEvents(gameLoop : GameLoop) : Unit
  val event = pygame.event.poll()
  def f() : Unit
    gameLoop.processEvent(event)
    processEvents(gameLoop)
  helper.getType(event).equals(pygame.NOEVENT).ifTrue(
    () => 0,
    () => f())
def run(gameLoop : GameLoop) : Unit
  clock.tick(gameLoop.fps)
  gameLoop.oneIteration()
  processEvents(gameLoop)
  gameLoop.done.ifTrue(
    () => 0,
    () => run(gameLoop))

val width = 640
val height = 480
val screen = pygame.display.set_mode(helper.make2Tuple(width, height), 0, 0)

// def ifTrue(bool : Boolean, f : Unit -> Dyn) : Unit
//   bool.ifTrue(() => f(), () => 0)

val ball = new
  var x : Int = 0
  var y : Int = 0
  val radius = 10
  var xSpeed : Int = 2
  var ySpeed : Int = 2

  def draw(screen : Surface) : Unit
    pygame.draw.circle(screen, helper.white, helper.make2Tuple(this.x, this.y), this.radius)
    7

  def update(paddleHitbox : Rect) : Unit
    (this.x < 0).ifTrue(() => this.xSpeed = (0 - 1) * this.xSpeed, () => 0)
    (this.x > width).ifTrue(() => this.xSpeed = (0 - 1) * this.xSpeed, () => 0)
    (this.y < 0).ifTrue(() => this.ySpeed = (0 - 1) * this.ySpeed, () => 0)
    (this.y > height).ifTrue(() => this.ySpeed = (0 - 1) * this.ySpeed, () => 0)

    // backwards comparisons for better ifTrue nesting
    val me = this
    (me.x > paddleHitbox.right).ifTrue(() => 0,
      () => (me.x < paddleHitbox.left).ifTrue(() => 0,
        () => (me.y < paddleHitbox.top).ifTrue(() => 0,
          () => (me.y > paddleHitbox.bottom).ifTrue(() => 0,
            () => (me.xSpeed > 0).ifTrue(() => 0,
              () => me.xSpeed = (0 - 1) * me.xSpeed
            )
          )
        )
      )
    )

    this.x = this.x + this.xSpeed
    this.y = this.y + this.ySpeed

val loop : GameLoop = new
  val fps = 144
  var y : Int = 10
  var done : Boolean = false

  var upPressed : Boolean = false
  var downPressed : Boolean = false

  val width = 20
  val height = 60

  def oneIteration() : Unit
    screen.fill(helper.black)
    pygame.draw.rect(screen, helper.white, pygame.Rect(10, this.y, this.width, this.height), 0)
    ball.draw(screen)
    pygame.display.flip()

    val gameLoop = this
    this.upPressed.ifTrue(() => gameLoop.y = gameLoop.y - 2,
                          () => 0)
    this.downPressed.ifTrue(() => gameLoop.y = gameLoop.y + 2,
                            () => 0)
    ball.update(pygame.Rect(10, this.y, this.width, this.height))

    // (this.y > 500).ifTrue(
    //   () => this.done = true,
    //   () => 7
    // )

  def processEvent(e : Event) : Unit
    val gameLoop = this
    val eventType = helper.getType(e)
    eventType.equals(pygame.QUIT).ifTrue(
      () => this.done = true,
      () => eventType.equals(pygame.KEYDOWN).ifTrue(
         () => e.key.equals(pygame.K_UP).ifTrue(
           () => gameLoop.upPressed = true,
           () => e.key.equals(pygame.K_DOWN).ifTrue(
             () => gameLoop.downPressed = true,
             () => 0)
         ),
         () => eventType.equals(pygame.KEYUP).ifTrue(
           () => e.key.equals(pygame.K_UP).ifTrue(
             () => gameLoop.upPressed = false,
             () => e.key.equals(pygame.K_DOWN).ifTrue(
               () => gameLoop.downPressed = false,
               () => 0)
           ),
           () => 0
         )
      ))

run(loop)
pygame.quit()
