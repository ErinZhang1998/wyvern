// http://wiki.erights.org/wiki/Walnut/Secure_Distributed_Computing/Capability_Patterns#Sealers_and_Unsealers

/*
# E version that may have concurrency issues due to using "shared" variable in non-E languages:
def makeBrandPair(nickname) {
     def noObject{}
     var shared := noObject
     def makeSealedBox(obj) {
         def box {
             to shareContent() {shared := obj}
         }
         return box
     }
     def sealer {
         to seal(obj) {return makeSealedBox(obj)}
     }
     def unsealer {
         to unseal(box) {
             shared := noObject
             box.shareContent()
             if (shared == noObject) {throw("invalid box")}
             def contents := shared
             shared := noObject
             return contents
         }
     }
     return [sealer, unsealer]
}
*/

/*
// JavaScript version building on closures:
function make_sealer () {
         var boxes = [], values = [];
         return {
		sealer: function (value) {
			var i = boxes.length, box = {};
			boxes[i] = box;
			values[i] = value;
			return box;
                },
		unsealer: function (box) {
			return values[boxes.indexOf(box)];
                }
         };
}
*/

module capabilities

import wyvern.option
import wyvern.collections.map
import wyvern.collections.list
import wyvern.String

// This example would be a lot nicer if parameterised Option[T]
// worked! Will rewrite when this bug is fixed. :-)
type Option = option.Option

type Map = map.Map

type List = list.List

type Box
     val name:String

resource type Sealer
     def seal(object:Option):Box

resource type Unsealer
     def unseal(box:Box):Option

// This example would be a lot nicer if we can pass tuples or pairs as
// return type! Will rewrite when supported. :-)
resource type SealerUnsealer
     var sealer:Sealer
     var unsealer:Unsealer

def makeSealerUnsealer():SealerUnsealer
    var map:Map = map.make((b1:Box,b2:Box) => String.equals(b1.name,b2.name))
    new
        var sealer:Sealer = new
            def seal(object:Option):Box
                val newBox:Box = new
                    val name:String = "NEED TO GENERATE UNIQUE STRING"
                map.put(newBox,object)
                newBox
        var unsealer:Unsealer = new
            def unseal(box:Box):Option
                map.get(box)

resource type SealedBox
    def shareContent():Unit

resource type BrandSealer
    def seal(object:Option):SealedBox

resource type BrandUnsealer
    def unseal(box:SealedBox):Option

resource type BrandPair
    var sealer:BrandSealer
    var unsealer:BrandUnsealer

def makeBrandPair():BrandPair
    var shared:Option = option.None()
    def makeSealedBox(object:Option):SealedBox
        val newBox:SealedBox = new
            def shareContent():Unit
                shared = object
        newBox
    new
        var sealer:BrandSealer = new
            def seal(object:Option):SealedBox
                return makeSealedBox(object)
        var unsealer:BrandUnsealer = new
            def unseal(box:SealedBox):Option
                shared = option.None()
                box.shareContent()
                var result:Option = shared
                result
