module ast

import wyvern.internal.list
import java:wyvern.stdlib.support.AST.utils

type AST
	val ast:Unit

type Decl
	val decl:Unit

type Type
	val typ:Unit

type VarBinding
  val binding:Unit

type Case
  val caseValue:Unit

def varBinding(varName : String, varType : Type, toReplace : AST) : VarBinding = new
  val binding:Unit = utils.varBinding(varName, varType, toReplace)

def makeCase(varName : String, pattern : Type, body : AST) : Case = new
  val caseValue:Unit = utils.makeCase(varName, pattern, body)

def bind(bindings : list.List, inExpr : AST) : AST = new
  val ast:Unit = utils.bind(bindings, inExpr)

def object(decls : list.List) : AST = new
	val ast:Unit = utils.object(decls)

def defn(name:String,resultType:Type,body:AST):Decl = new
	val decl:Unit = utils.OneArgDefn(name, resultType, body)

def int(i:Int):AST = new
	val ast:Unit = utils.intLiteral(i)

def boolean(b:Boolean):AST = new
  val ast:Unit = utils.booleanLiteral(b)

def string(s:String):AST = new
	val ast:Unit = utils.stringLiteral(s)

def variable(s:String):AST = new
	val ast:Unit = utils.variable(s)

def call(receiver:AST, methodName:String, arguments:list.List):AST = new
	val ast:Unit = utils.methodCall(receiver,methodName, arguments)

def cast(toCastExpr : AST, exprType : Type) : AST = new
  val ast:Unit = utils.cast(toCastExpr, exprType)

def ffi(importName : String, importType : Type) : AST = new
  val ast:Unit = utils.ffi(importName, importType)

def ffiImport(ffiType : Type, path : String, importType : Type) : AST = new
  val ast:Unit = utils.ffiImport(ffiType, path, importType)

def fieldGet(objectExpr : AST, fieldName : String) : AST = new
  val ast:Unit = utils.fieldGet(objectExpr, fieldName)

def fieldSet(exprType : Type, object : AST, fieldName : String, exprToAssign : AST) : AST = new
  val ast:Unit = utils.fieldSet(exprType, object, fieldName, exprToAssign)

def matchExpr(matchExpr : AST, elseExpr : AST, cases : list.List) : AST = new
  val ast:Unit = utils.matchExpr(matchExpr, elseExpr, cases)

def parseExpression(input : String, ctx : system.Context) : AST
  val ctxDyn:Dyn = ctx
  new
    val ast:Unit = utils.parseExpression(input, ctxDyn)

val types = new
  def int():Type = new
    val typ:Unit = utils.intType()

  def dyn():Type = new
    val typ:Unit = utils.dynType()

  def unit():Type = new
    val typ:Unit = utils.unitType()

  def nominal(pathVariable : String, typeMember : String):Type = new
    val typ:Unit = utils.nominalType(pathVariable, typeMember)

def stripLeadingWhitespace(input : String) : String = utils.stripLeadingWhitespace(input)

def genIdent() : String = utils.genIdent()

def let(ident : String, bindingType : Type, bindingValue : AST, inExpr : AST) : AST = new
  val ast:Unit = utils.let(ident, bindingType, bindingValue, inExpr)