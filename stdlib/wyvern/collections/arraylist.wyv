module def arraylist(java : Java)

import java:wyvern.stdlib.support.ArrayWrapper.arr
import wyvern.collections.Iterator
import wyvern.option

type Option = option.Option
type Some = option.Some 
type None = option.None

resource type ArrayList
    type E
    def size() : Int
    def isEmpty() : Boolean
    def do(f:this.E->Unit):Unit
    def length() : Int
    def get(index : Int) : this.E
    /* Can only set elements that are already initialized */
    def set(index : Int, elem : this.E) : Unit
    def add(x : this.E) : Unit 
    def addAt(i:Int, x:this.E):Unit 
    def addAll(l:ArrayList[this.E]):Unit
    def indexOf(x: this.E, compare: this.E*this.E->Boolean):Int
    def iterator(): Iterator[this.E]
    def map[U](f:this.E->U):ArrayList[U]
    def foldLeft[U](f:U*this.E->U, x:U):U
    def foldRight[U](f:this.E*U->U, x:U):U
    def reverse():ArrayList[this.E]
    def reduce(f:this.E*this.E=>this.E, id:this.E):this.E
    def filter(f:this.E->Boolean):ArrayList[this.E]


def ArrayList[T](count : Int) : ArrayList[T] = new
    type E = T
    var array : Unit = arr.create(count) 
    
    var arrSize : Int = 0
    def size() : Int = this.arrSize
    
    def isEmpty() : Boolean
        this.arrSize == 0
    
    def do(f:T->Unit):Unit
        def setNewArray(i:Int, x:T):Int
            f(this.get(i))
            i+1
        this.foldLeft[Int]((i:Int, x:T) \
            => setNewArray(i, x), 0)
        unit
    
    def length() : Int
        arr.length(this.array) 
    
    def get(index : Int) : T
        if(index<0 || index > this.arrSize-1)
          runtime.fail("Error: index out of bounds")
         else
          arr.get(this.array, index)
    
    def set(index : Int, elem : T) : Unit 
        if(index < 0 || index > this.arrSize-1)
          runtime.fail("Error: Index out of bounds")
         else
          arr.set(this.array, index, elem)

    /* implicitly requires that i starts at 0 */
    def copyToFrom(newArr : Unit, oldArr : Unit, i : Int, j : Int) : Unit 
        if(i<0 || i > j-1)
          unit
         else
          arr.set(newArr, i, arr.get(oldArr, i))
          this.copyToFrom(newArr, oldArr, i+1, j)

    /* grow the internal java array to at least targetLength */
    def growArray(targetLength : Int) : Unit
        var newLength : Int = this.length() * 2
        if(newLength < targetLength)
          newLength = targetLength
        var newArray : Unit = arr.create(newLength)
        newArray

    def growArrayAndCopy(targetLength:Int) : Unit 
        var newArray : Unit = this.growArray(targetLength)
        this.copyToFrom(newArray, this.array, 0, this.arrSize)
        newArray

    def add(x : T) : Unit
        var newArray : Unit = this.array
        if(this.arrSize + 1 > this.length())
          newArray = this.growArrayAndCopy(this.arrSize + 1)
        this.arrSize = this.arrSize + 1
        this.array = newArray
        this.set(this.arrSize-1, x)
        unit

    /* coping oldArr[i:j] (exlude j) to newArr starting at h, but not >= k */
    def copyToFromRange(newArr : Unit, oldArr : Unit, h : Int, k : Int, i : Int, j : Int) : Unit 
        def copyToFromRangeH(z:Int) : Unit
            if(i<0 || i > j-1 || h+z > k-1)
              unit 
             else
              arr.set(newArr, h+z, arr.get(oldArr, i+z) )
              copyToFromRangeH(z+1)
        copyToFromRangeH(0)

    def addAt(i:Int, x:T):Unit 
        val oldSize = this.arrSize
        val newSize = this.arrSize+1
        if(i<0 || i > oldSize)
          runtime.fail("Error: Index out of bounds")
         else
          var newArray : Unit = unit 
          if(newSize > this.length())
            newArray = this.growArray(newSize)
           else
            if(i==oldSize)
              newArray = this.array 
             else 
              newArray = arr.create(this.length())
          this.copyToFromRange(newArray, this.array, 0, i, 0, i)
          arr.set(newArray, i, x)
          this.copyToFromRange(newArray, this.array, i+1, newSize, i, oldSize)
          this.array = newArray
          this.arrSize = newSize
          unit
          


    def addAll(l:ArrayList[T]):Unit
        val lSize = l.size()
        val newSize = this.arrSize+lSize
        var newArray : Unit = this.array
        if(newSize > this.length())
          newArray = this.growArrayAndCopy(newSize)
        def addAllH(Arr: Unit, i:Int):Unit 
            if(i < lSize)
              arr.set(Arr, this.arrSize+i, l.get(i))
              addAllH(Arr, i+1)
             else
              unit 
        addAllH(newArray, 0)
        this.array = newArray
        this.arrSize = newSize
        unit

    def indexOf(x: T, compare: T*T->Boolean):Int
        def indexOfH(i:Int):Int
            if(i< this.arrSize)
              if(compare(this.get(i), x))
                i 
               else
                indexOfH(i+1)
             else
              -1
        indexOfH(0)

    def iterator():Iterator[T] = new (self) => 
        type E = T
        var currentIndex : Int = 0
        def hasNext():Boolean = self.currentIndex < this.arrSize
        def next(): Option[T]
            if(self.hasNext())
              val lastIndex = self.currentIndex
              self.currentIndex = self.currentIndex + 1
              option.Some[T](this.get(lastIndex))
             else
              option.None[T]()

    def map[U](f:T->U): ArrayList[U]
        var newArray : ArrayList[U] = ArrayList[U](this.arrSize)
        def mapH[U](f:T->U, newarr:ArrayList[U], i:Int): Unit
            if(i < this.arrSize)
              val nextelem = f(this.get(i))
              newarr.add(nextelem)
              mapH[U](f, newarr, i+1)
             else
              unit

        mapH[U](f, newArray, 0)
        newArray

    def foldLeft[U](f:U*T->U, x:U):U
        def foldLeftH[U](f:U*T->U, y:U, i:Int):U
            if(i < this.arrSize)
              foldLeftH[U](f, f(y, this.get(i)), i+1)
             else
              y
        foldLeftH[U](f,x,0)

    def reverse():ArrayList[T]
        var newArrayList : ArrayList[T] = ArrayList[T](this.arrSize)
        def setNewArray(newArr: ArrayList[T], i:Int):Unit
            if(i<0 || i > this.arrSize-1)
              unit 
             else
              newArr.add(this.get(i))
              setNewArray(newArr, i-1)
        setNewArray(newArrayList, this.arrSize-1)
        newArrayList

    def foldRight[U](f:T*U->U, x:U):U
        var revArrayList : ArrayList[T] = this.reverse()
        revArrayList.foldLeft[U]((foldRes:U, ele:T) => f(ele,foldRes), x)

    def reduce(f:T*T=>T, id:T):T
        def reduceH(f:T*T=>T, id:T, i:Int, j:Int):T
            if(j-i < 2)
              this.get(i)
             else
              val mid : Int = i + ((j-i) / 2)
              val fstHalf = reduceH(f, id, i, mid)
              val sndHalf = reduceH(f, id, mid, j)
              f(fstHalf, sndHalf)
        reduceH(f, id, 0, this.arrSize)

    def filter(f:T->Boolean): ArrayList[T] 
        var revArrayList : ArrayList[T] = this.reverse()
        var newArrayList : ArrayList[T] = ArrayList[T](0)
        def setNewArray(newArr : ArrayList[T], x:T): ArrayList[T]
            if(f(x))
              newArr.add(x)
              newArr
             else
              newArr
        this.foldLeft[ArrayList[T]]((newArr : ArrayList[T], x:T) \
            => setNewArray(newArr, x), newArrayList)

def tabulate[T](f:Int->T, n:Int):ArrayList[T]
    var newArrayList : ArrayList[T] = ArrayList[T](n) //arraylist internal contructor
    def tabulateH[T](f:Int->T, n:Int, arr:ArrayList[T], i:Int):ArrayList[T]
        if(n==0)
          arr
         else
          val thisVal : T = f(i)
          arr.add(thisVal)
          tabulateH[T](f, n-1, arr, i+1)
    tabulateH[T](f,n,newArrayList, 0)