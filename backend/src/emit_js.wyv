module emit_js

import wyvern.collections.list
import wyvern.option
import wyvern.String
import platform.java.debug

import wyb_ast
import util

type Option = option.Option
type List = list.List

def visitTypeDeclaration(td: wyb_ast.TypeDeclaration): String
    val defn = td.name + " = function() {};"
    if (td.typeDesc.tdExtends.isDefined)
            td.name + " = function() { var " + defn + "\n" + td.name + ".prototype = new " + util.unwrap[String](td.typeDesc.tdExtends) + "(); return " + td.name + ";}()"
        else
            defn

def visitDeclaration(d: wyb_ast.Declaration): String = match d:
    vd: wyb_ast.VariableDeclaration => vd.variable + " = " + visitExpression(vd.initializer) + ";"
    md: wyb_ast.MethodDeclaration => md.methodName + "= function(" + util.join(md.arguments.map[String](a => a.variable), ",")+ ") { return "  + visitExpression(md.body) + ";}" + "\n"
    td: wyb_ast.TypeDeclaration => visitTypeDeclaration(td)

def visitStatement(s : wyb_ast.Statement): String = match s:
    e: wyb_ast.E => visitExpression(e.expression)
    d: wyb_ast.D => "var " + visitDeclaration(d.declaration)

def ifTrue(cond: wyb_ast.Expression, trueArm: wyb_ast.Expression, falseArm: wyb_ast.Expression): String
    val c = visitExpression(cond)
    val t = visitExpression(trueArm)
    val f = visitExpression(falseArm)
    // HACK: hard codes calling ._apply(), dependent on rename pass
    "(function() { if (" + c + ") { return " + t + "._apply(); } else { return " + f + "._apply(); } })()"

def visitCallExpression(c: wyb_ast.CallExpression): String
    // HACK: hard codes looking for _print, dependent on rename pass
    if (c.method == "_print")
            val e = util.unwrap[wyb_ast.Expression](c.arguments.get(0))
            "process.stdout.write(\"\"+" + visitExpression(e) + ")"
        else
            visitExpression(c.receiver) + "." + c.method + "(" + util.join(c.arguments.map[String](e => visitExpression(e)), ",") + ")"


// is this the best way to get the tag information off something that's
// potentially a refinement type?
def newTypeExtends(nt: wyb_ast.Type): Option = match nt:
    ct: wyb_ast.CompoundType => newTypeExtends(ct.base)
    tp: wyb_ast.TypePath => option.Some[String](tp.path)
    default => option.None[String]()

def visitNewExpression(n: wyb_ast.NewExpression): String
    val ext = newTypeExtends(n.t)
    val c = "function() {\nvar " + n.thisVariable + " = this; " + util.join(n.declarations.map[String](e => n.thisVariable + "." + visitDeclaration(e)), "\n") + "}"
    if (ext.isDefined)
            val e = util.unwrap[String](ext)
            "new (function() { var c = " + c + "; c.prototype = new " + e + "(); return c;}())()"
        else
            "new (" + c + ")()"

def sequenceExpression(s: wyb_ast.SequenceExpression): String
    def loop(statements: List[wyb_ast.Statement], i: Int, acc: String): String
        val s = util.unwrap[wyb_ast.Statement](statements.get(i))
        if (i > statements.length() - 2)
                acc + "; return " + visitStatement(s) + ";"
            else
                loop(statements, i + 1, acc + ";" + visitStatement(s))
    assert s.statements.length() > 0
    "(function(){" + loop(s.statements, 0, "") + "})()"

def unescape(s: String): String
    def loop(s: String, acc: String): String
        if (s == "")
                acc
            elif (s.substring(0, 1) == "'")
                loop(s.substring(1, s.length()), acc + "\\'")
            elif (s.substring(0, 1) == '"')
                loop(s.substring(1, s.length()), acc + '\\"')
            elif (s.substring(0, 1) == "\b")
                loop(s.substring(1, s.length()), acc + "\\b")
            elif (s.substring(0, 1) == "\f")
                loop(s.substring(1, s.length()), acc + "\\f")
            elif (s.substring(0, 1) == "\n")
                loop(s.substring(1, s.length()), acc + "\\n")
            elif (s.substring(0, 1) == "\r")
                loop(s.substring(1, s.length()), acc + "\\r")
            elif (s.substring(0, 1) == "\t")
                loop(s.substring(1, s.length()), acc + "\\t")
            else
                loop(s.substring(1, s.length()), acc + s.substring(0, 1))
    loop(s, "")

def booleanToString(x: Boolean): String
    if (x)
            "true"
        else
            "false"

def isBinOp(m: String): Boolean
    m == '+' || m == '-' || m == '<' || m == '==' || m == '*' || m == '>' || m == '&&' || m == '||' || m == '/' || m == '%'

// TODO: floor
def visitPrimitiveCallExpression(e: wyb_ast.PrimitiveCallExpression): String
    val op = e.method
    if (op == "negate")
            assert e.arguments.length() == 0
            "(-(" + visitExpression(e.receiver) + "))"
        elif (op == "!")
            assert e.arguments.length() == 0
            "(-(" + visitExpression(e.receiver) + "))"
        elif (op == "length")
            assert e.arguments.length() == 0
            "(" + visitExpression(e.receiver) + ").length"
        elif (op == "charAt" || op == "substring" || op == "concat")
            visitExpression(wyb_ast.CallExpression(e.receiver, op, e.arguments))
        elif (op == "ifTrue")
            val t = util.unwrap[wyb_ast.Expression](e.arguments.get(0))
            val f = util.unwrap[wyb_ast.Expression](e.arguments.get(1))
            ifTrue(e.receiver, t, f)
        elif (isBinOp(op))
            val lhs = e.receiver
            val rhs = util.unwrap[wyb_ast.Expression](e.arguments.get(0))
            "(" + visitExpression(lhs) + ") " + op + " (" +  visitExpression(rhs) + ")"
        else
            runtime.fail("visited unrecognized primitive op '" + op + "'in emit_js")
            runtime.fail("visited unrecognized primitive op in emit_js")


def visitExpression(e: wyb_ast.Expression): String = match e:
    v: wyb_ast.Var => v.v
    i: wyb_ast.IntegerLiteral => String.ofInt(i.i)
    b: wyb_ast.BooleanLiteral => booleanToString(b.b)
    f: wyb_ast.FloatLiteral => String.ofFloat(f.f)
    s: wyb_ast.StringLiteral => '"' + unescape(s.s) + '"'
    n: wyb_ast.NewExpression => visitNewExpression(n)
    c: wyb_ast.CallExpression => visitCallExpression(c)
    s: wyb_ast.SequenceExpression => sequenceExpression(s)
    poe: wyb_ast.PrimitiveCallExpression => visitPrimitiveCallExpression(poe)
    me: wyb_ast.MatchExpression =>  "(function() { var e = " + visitExpression(me.e) +";" + visitMatchBody(me.arms, me.elseClause) + "})()"
    ae: wyb_ast.AccessExpression => "(" + visitExpression(ae.e) + ")" + "." + ae.field
    ae: wyb_ast.AssignmentExpression => "(" + visitExpression(ae.e) + ")" + "." + ae.field + " = " + visitExpression(ae.v)

def visitMatchBody(arms: List[wyb_ast.MatchArm], elseClause: Option[wyb_ast.Expression]): String
    var elseString: String = ""
    if (elseClause.isDefined)
        elseString = "else { return " + visitExpression(util.unwrap[wyb_ast.Expression](elseClause)) + ";}"
    util.join(arms.map[String](a => "if (e instanceof " + a.path + ") { var " + a.variable + " = e; return " + visitExpression(a.e) + ";}"), " else ") + elseString

