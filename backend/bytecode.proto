syntax = "proto2";

// x : \tau (used in methods and method types)
message MethodArgument {
    required string variable = 1;
    required Type type = 2;
}

// Variable declarations are either val or var
enum VariableDeclarationType {
    VAL = 1;
    VAR = 2;
}

// type L = T
message TypeDeclaration {
    required string name = 1;
    required TypeDesc typeDesc = 2;
}

// b
message Bytecode {
    // v
    message Version {
        // Magic number? Having one doesn't make sense if we're using protobuf
        // since it can do validation of bytestreams.
        required string major = 1;
        required string minor = 2;
    }
    // i
    message Import {
        enum ImportType {
            METADATA = 1;
            TYPE = 2;
        }
        optional ImportType importType = 1;
        required string platform = 2;
        // Need to make a global decision here: In the bytecode should we store
        // paths as '.' delimited strings or arrays of strings? What about
        // little 'p' paths used in match expressions, datatags, etc?
        required string path = 3;
        required Type type = 4;
        required string name = 5;
    }
    required Version version = 1;
    required string path = 2;
    repeated Import imports = 3;
    required Module module = 4;
}

// M
message Module {
    message ExpressionModule {
        required string path = 1;
        required Type type = 2;
        required Expression expression = 3;
    }
    oneof module {
        ExpressionModule expressionModule = 1;
        TypeDeclaration typeModule = 2;
    }
}

// e
message Expression {
    message NewExpression {
        required Type type = 1;
        required string this = 2;
        repeated Declaration declarations = 3;
    }
    message CallExpression {
        required Expression callee = 1;
        required string method = 2;
        repeated Expression arguments = 3;
    }
    message AccessExpression {
        required Expression expression = 1;
        required string field = 2;
    }
    message AssignmentExpression {
        required Expression expression = 1;
        required string field = 2;
        required Expression value = 3;
    }
    message LetExpression {
        required string variable = 1;
        required Expression value = 2;
        required Expression expression = 3;
    }
    message Literal {
        oneof literal {
            string string = 1;
            bytes integer = 2;
        }
    }
    message MatchExpression {
        message MatchArm {
            required string variable = 1;
            required string path = 2;
            required Expression expression = 3;
        }
        required Expression expression = 1;
        repeated MatchArm arms = 2;
        optional Expression else = 3;
    }
    oneof expression {
        string variable = 1;
        NewExpression newExpression = 2;
        CallExpression callExpression = 3;
        AccessExpression accessExpression = 4;
        AssignmentExpression assignmentExpression = 5;
        LetExpression letExpression = 6;
        Literal literal = 7;
    }
}

// d
message Declaration {
    message VariableDeclaration {
        required VariableDeclarationType declarationType = 1;
        required string variable = 2;
        required Type type = 3;
        required string value = 4;
    }
    message MethodDeclaration {
        required string methodName = 1;
        repeated MethodArgument arguments = 2;
        required Type returnType = 3;
        required Expression body = 4;
    }
    oneof declaration {
        VariableDeclaration variableDeclaration = 1;
        MethodDeclaration methodDeclaration = 2;
        TypeDeclaration typeDeclaration = 3;
    }
}

// T
message TypeDesc {
    // c
    message CaseDesc {
        optional string extends = 1;
        required Type type = 2;
    }
    message ExTag {
        // empty?
    }
    message DataTag {
        repeated string paths = 1;
    }
    required CaseDesc caseDesc = 1;
    optional ExTag extag = 2;
    optional DataTag datatag = 3;
    optional Expression metaData = 4;
}

// \tau
message Type {
    // \tau { x => \overline{\sigma} }_s
    message CompoundType { // better name?
        required Type base = 1; // better name?
        required string this = 2;
        repeated DeclType declTypes = 3;
        required Statefulness statefulness = 4;
    }
    enum SpecialType { // better name? PrimitiveType?
        Top = 1;
        Dyn = 2;
        // Missing \bot type (expression has no value)?
    }
    oneof type {
        CompoundType declarationType = 1;
        string path = 2;
        SpecialType specialType = 3;
    }
}

// s
enum Statefulness {
    STATEFUL = 1;
    PURE = 2;
}

// \sigma
message DeclType {
    message VariableDeclType {
        required VariableDeclarationType declarationType = 1;
        required string variable = 2;
        required Type type = 3;
    }
    message MethodDeclType {
        required string methodName = 1;
        repeated MethodArgument arguments = 2;
        required Type returnType = 3;
    }
    message OpaqueTypeDecl {
        required string name = 1;
        required Statefulness statefullness = 2;
    }
    oneof declaration {
        VariableDeclType variableDecl = 1;
        MethodDeclType methodDecl = 2;
        TypeDeclaration typeDeclaration = 3;
        OpaqueTypeDecl opaqueTypeDecl = 4;
    }
}
